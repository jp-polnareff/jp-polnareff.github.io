{"title":"Pulsar之message篇","uid":"55ea1ac8b6eebb4c3c1010cae15373f5","slug":"mq/pulsar_message","date":"2021-04-06T10:32:47.000Z","updated":"2022-01-02T16:47:54.080Z","comments":true,"path":"api/articles/mq/pulsar_message.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image.4caxs5p9qou0.png","content":"<h1 id=\"Pulsar之message篇\"><a href=\"#Pulsar之message篇\" class=\"headerlink\" title=\"Pulsar之message篇\"></a>Pulsar之message篇</h1><p>Pulsar建立在pub-sub上，该设计模式中，producer 发布消息到 topic， Consumer 订阅 topic、处理发布的消息，并在处理完成后发送确认。</p>\n<p>一旦创建订阅，即使 consumer 断开连接，Pulsar 仍然可以保存所有消息。 在 consumer 确认消息已处理成功后，才会删除消息。</p>\n<h2 id=\"message\"><a href=\"#message\" class=\"headerlink\" title=\"message\"></a>message</h2><table>\n<thead>\n<tr>\n<th align=\"left\">Component</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Value / data payload</td>\n<td align=\"left\">消息所承载的数据。 尽管消息数据也可以符合数据 schemas，但所有 Pulsar 消息都包含原始字节。</td>\n</tr>\n<tr>\n<td align=\"left\">Key</td>\n<td align=\"left\">消息可以选择用键进行标记，这在 topic 压缩等操作很有用。</td>\n</tr>\n<tr>\n<td align=\"left\">Properties</td>\n<td align=\"left\">用户自定义属性的键值对（可选）。</td>\n</tr>\n<tr>\n<td align=\"left\">Producer name</td>\n<td align=\"left\">生成消息的 producer 的名称。 如果不指定，则使用默认名称</td>\n</tr>\n<tr>\n<td align=\"left\">Sequence ID</td>\n<td align=\"left\">每个 Pulsar 消息都存储在其主题上的有序序列中。消息的序列 ID 是其在该序列中的顺序。</td>\n</tr>\n<tr>\n<td align=\"left\">Publish time</td>\n<td align=\"left\">消息发布的时间戳，由 producer 自动添加。</td>\n</tr>\n<tr>\n<td align=\"left\">Event time</td>\n<td align=\"left\">应用程序可以附加到消息的时间戳（可选）， 例如处理消息的时间。 如果没有明确设置，则消息的事件时间为 <code>0</code>。</td>\n</tr>\n<tr>\n<td align=\"left\">TypedMessageBuilder</td>\n<td align=\"left\">用于构造消息。 您可以使用 <code>TypedMessageBuilder</code> 设置消息的键值对属性。<br/>在设置 <code>TypedMessageBuilder</code> 时，最佳的选择是将 key 设置为字符串。 如果将 key 设置为其他类型（例如，AVRO 对象），则 key 会以字节形式发送，这时 consumer 就很难使用了。</td>\n</tr>\n</tbody></table>\n<p>message默认大小问<strong>5M</strong>，自定义修改：</p>\n<p><code>broker.conf </code> 中</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># The max size of a message (in bytes).\nmaxMessageSize&#x3D;5242880</code></pre>\n\n<p><code>bookkeeper.conf </code> 中</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># 收到的任何大于此值的消息都将被拒绝\nnettyMaxFrameSizeBytes&#x3D;5253120</code></pre>\n\n\n\n<h2 id=\"Producer\"><a href=\"#Producer\" class=\"headerlink\" title=\"Producer\"></a>Producer</h2><table>\n<thead>\n<tr>\n<th>发送模式</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>同步发送</td>\n<td>Producer 将在发送每条消息后等待 broker 的确认。 如果未收到确认，则 producer 将认为发送失败。</td>\n</tr>\n<tr>\n<td>异步发送</td>\n<td>Producer 将把消息放于阻塞队列中，并立即返回然后，客户端将在后台将消息发送给 broker。</td>\n</tr>\n</tbody></table>\n<p>Producer API提供了4种不同的选项，用于将消息发送到代理：</p>\n<ol>\n<li>同步单发布</li>\n<li>异步单发布</li>\n<li>同步批量发布</li>\n<li>异步批量发布（我们的选择，异步发送具有重试机制，最大重试计数设置为10）</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">return pulsarClient.newProducer(Schema.STRING)\n  .topic(xxx)\n  &#x2F;&#x2F; 10ms或者队列message达到100发送\n  .batchingMaxPublishDelay(10, TimeUnit.MILLISECONDS)\n  .batchingMaxMessages(100)\n  &#x2F;&#x2F; 如果在sendTimeout到期之前服务器未确认消息，则将报告错误。\n  .sendTimeout(10, TimeUnit.SECONDS)\n  &#x2F;&#x2F; 消息队列已满时，阻塞\n  .blockIfQueueFull(true)\n  .create();\n&#x2F;&#x2F; 其余还可自行设置messageRoutingMode、compressionType等等\n&#x2F;&#x2F;compressionType支持LZ4、ZLIB、ZSTD、SNAPPY四种</code></pre>\n\n<p>Pulsar具有重复数据删除机制以提供精确的一次处理。启用重复数据删除后，Pulsar代理将删除重复的消息。它通过查看<code>SequenceId</code>在发布时添加的消息字段来检测重复项。</p>\n<h3 id=\"路由模式\"><a href=\"#路由模式\" class=\"headerlink\" title=\"路由模式\"></a>路由模式</h3><p>有三种 MessageRoutingMode 可用:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">发送模式</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>RoundRobinPartition</code></td>\n<td align=\"left\">如果消息没有指定 key，为了达到最大吞吐量，消息会以 round-robin 方式被路由所有分区。 如果为消息指定了key，发往分区的消息会被分区生产者根据 key 做 hash，然后分散到对应的分区上。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>SinglePartition</code></td>\n<td align=\"left\">如果消息没有指定 key，生产者将会随机选择一个分区，并发送所有消息。 如果为消息指定了key，发往分区的消息会被分区生产者根据 key 做 hash，然后分散到对应的分区上。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>CustomPartition</code></td>\n<td align=\"left\">使用自定义消息路由，可以定制消息如何进入特定的分区。</td>\n</tr>\n</tbody></table>\n<p><strong>消息的顺序</strong>与MessageRoutingMode和Message Key相关：</p>\n<ul>\n<li>使用 <code>SinglePartition</code> 或 <code>RoundRobinPartition</code> 模式，每条消息都有key，所有具有相同 key 的消息将按顺序排列并放置在相同的分区（Partition）中。</li>\n<li>路由策略为<code>SinglePartition</code>, 且每条消息都没有key，来自同一生产者的所有消息都是有序的。</li>\n</ul>\n<h2 id=\"Consumer\"><a href=\"#Consumer\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h2><p>Consumer提供了三类获取消息的方式：</p>\n<ul>\n<li>同步接收消息</li>\n<li>异步接收消息：通过Future返回消息</li>\n<li>通过MessageListener返回消息（目前在用的）</li>\n</ul>\n<p><strong>At least once</strong> 模型：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class AbstractMessageListener&lt;T&gt; implements MessageListener&lt;T&gt; &#123;\n\n    @Override\n    public void received(Consumer&lt;T&gt; consumer, Message&lt;T&gt; message) &#123;\n        try &#123;\n            &#x2F;&#x2F; processing\n            consumer.acknowledge(message);\n        &#125; catch (Exception e) &#123;\n            consumer.negativeAcknowledge(message);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>At most once</strong> 模型：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class AbstractMessageListener&lt;T&gt; implements MessageListener&lt;T&gt; &#123;\n\n    @Override\n    public void received(Consumer&lt;T&gt; consumer, Message&lt;T&gt; message) &#123;\n        try &#123;\n            &#x2F;&#x2F; processing\n        &#125; catch (Exception e) &#123;\n            log.error(&quot;processing error&quot;, e);\n        &#125; finally &#123;\n            consumer.acknowledge(message);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">return pulsarClient.newConsumer(Schema.STRING)\n  \t\t\t&#x2F;&#x2F; 订阅的topic列表\n        .topics(Collections.singletonList(xxxtopic))\n  \t\t\t&#x2F;&#x2F; 消费名称\n        .consumerName(x x x)\n  \t\t\t&#x2F;&#x2F; 订阅方式Exclusive、Shared、Failover、Key_Shared\n        .subscriptionType(SubscriptionType.Shared)\n  \t\t\t&#x2F;&#x2F; 订阅名称\n        .subscriptionName(xxx)\n  \t\t\t&#x2F;&#x2F; 从哪里开始消费\n  \t\t\t&#x2F;&#x2F; Latest 最新位置，这意味着开始消费位置将是最后一条消息\n  \t\t\t&#x2F;&#x2F; Earliest 最早的位置，这意味着开始消费的位置将是第一条消息\n        .subscriptionInitialPosition(SubscriptionInitialPosition.Latest)\n  \t\t\t&#x2F;&#x2F; 自己的linstener实现类\n        .messageListener(AbstractMessageListenerImpl)\n        .subscribe();</code></pre>\n\n<p>Messages的两种方式确认消息：</p>\n<ul>\n<li>单条确认模式：消息被单独确认，消费者需要确认每个消息，并将确认请求发送给broker。</li>\n<li>累积确认模式：消费者只需要确认最后一条他收到的消息。 所有之前（包含此条）的消息，都不会被再次发送给那个消费者。</li>\n</ul>\n<blockquote>\n<p>在共享订阅模式，消息都是单条确认模式</p>\n</blockquote>\n<h3 id=\"订阅模式\"><a href=\"#订阅模式\" class=\"headerlink\" title=\"订阅模式\"></a>订阅模式</h3><p><img src=\"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image.5snmypqjx5w0.png\" alt=\"img\"></p>\n<ul>\n<li>Exclusive：在独占模式下，仅允许单个使用者附加到订阅。如果多个使用者使用相同的订阅来订阅主题，则会发生错误</li>\n<li>Failover：<em>Failover</em>模式中，多个consumer可以绑定到同一个subscription。当主消费者断开连接时，所有（未确认和后续的）消息都会被发送、交付给下一个消费者。</li>\n<li>Shared：消息通过round robin轮询机制分发给不同的消费者，并且每个消息仅会被分发给一个消费者。 当消费者断开连接，所有被发送给他，但没有被确认的消息将被重新安排，分发给其它存活的消费者。</li>\n<li>Key_Shared：按 KEY 共享消费，多对多，Exclusive 和 Shared 的折中模式</li>\n</ul>\n<h2 id=\"Topic\"><a href=\"#Topic\" class=\"headerlink\" title=\"Topic\"></a>Topic</h2><h3 id=\"Dead-letter-topic\"><a href=\"#Dead-letter-topic\" class=\"headerlink\" title=\"Dead letter topic\"></a>Dead letter topic</h3><p>死信主题使您可以在使用者无法成功使用某些消息时使用新消息。 在这种机制下，无法使用的消息将存储在一个单独的主题中，该主题称为死信主题。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Consumer&lt;byte[]&gt; consumer &#x3D; pulsarClient.newConsumer(Schema.BYTES)\n              .topic(topic)\n              .subscriptionName(&quot;my-subscription&quot;)\n              .subscriptionType(SubscriptionType.Shared)\n              .deadLetterPolicy(DeadLetterPolicy.builder()\n                    .maxRedeliverCount(maxRedeliveryCount)\n                    .deadLetterTopic(&quot;your-topic-name&quot;)\n                    .build())\n              .subscribe();</code></pre>\n\n<blockquote>\n<p>死信主题仅在共享订阅模式下启用</p>\n</blockquote>\n<h3 id=\"Retry-letter-topic\"><a href=\"#Retry-letter-topic\" class=\"headerlink\" title=\"Retry letter topic\"></a>Retry letter topic</h3><p>对于许多在线业务系统，由于业务逻辑处理中发生异常，因此会重新使用一条消息。 要配置重用失败消息的延迟时间，可以配置生产者以将消息发送到业务主题和重试主题，并在使用者上启用自动重试。 在使用者上启用自动重试后，如果消息未被消费，则消息会存储在重试主题中，因此，consumer在指定的延迟时间后会自动消费来自重试主题的失败消息</p>\n<p>默认情况下，自动重试处于禁用状态。 您可以将enableRetry设置为true以对使用者启用自动重试。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Consumer&lt;byte[]&gt; consumer &#x3D; pulsarClient.newConsumer(Schema.BYTES)\n                .topic(topic)\n                .subscriptionName(&quot;my-subscription&quot;)\n                .subscriptionType(SubscriptionType.Shared)\n                .enableRetry(true)\n                .receiverQueueSize(100)\n                .deadLetterPolicy(DeadLetterPolicy.builder()\n                        .maxRedeliverCount(maxRedeliveryCount)\n                        .retryLetterTopic(&quot;persistent:&#x2F;&#x2F;my-property&#x2F;my-ns&#x2F;my-subscription-custom-Retry&quot;)\n                        .build())\n                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)\n                .subscribe();</code></pre>\n\n<h3 id=\"Partitioned-topics\"><a href=\"#Partitioned-topics\" class=\"headerlink\" title=\"Partitioned topics\"></a>Partitioned topics</h3><p>分区主题实际是通过在底层拥有 N 个内部主题来实现的，这个 N 的数量就是等于分区的数量。 当向分区的topic发送消息，每条消息被路由到其中一个broker。 Pulsar自动处理跨broker的分区分布。</p>\n<p>假如一个topic的消息被广播给两个consumer。 <strong>路由模式</strong>确定每条消息该发往哪个分区，而<strong>订阅模式</strong>确定消息传递给哪个消费者。吞吐能力的要求，决定了 分区/路由 的方式。</p>\n<h3 id=\"Non-persistent-topics\"><a href=\"#Non-persistent-topics\" class=\"headerlink\" title=\"Non-persistent topics\"></a>Non-persistent topics</h3><p>Pulsar支持<strong>非持久性主题</strong>，这些主题的消息从不持久存储到磁盘，只存在于内存中。 Pulsar也提供了非持久topic。非持久topic的消息不会被保存在硬盘上，只存活于内存中。当使用非持久topic分发时，杀掉Pulsar的broker或者关闭订阅者，此topic（ non-persistent)）上所有的瞬时消息都会丢失，意味着客户端可能会遇到消息缺失。</p>\n","feature":true,"text":"Pulsar之message篇Pulsar建立在pub-sub上，该设计模式中，producer 发布消息到 topic， Consumer 订阅 topic、处理发布的消息，并在处理完成后发送确认。 一旦创建订阅，即使 consumer 断开连接，Pulsar 仍然可以保存所有...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":14,"path":"api/categories/学习记录.json"}],"tags":[{"name":"Pulsar","slug":"Pulsar","count":2,"path":"api/tags/Pulsar.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Pulsar%E4%B9%8Bmessage%E7%AF%87\"><span class=\"toc-text\">Pulsar之message篇</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#message\"><span class=\"toc-text\">message</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Producer\"><span class=\"toc-text\">Producer</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">路由模式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Consumer\"><span class=\"toc-text\">Consumer</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">订阅模式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Topic\"><span class=\"toc-text\">Topic</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Dead-letter-topic\"><span class=\"toc-text\">Dead letter topic</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Retry-letter-topic\"><span class=\"toc-text\">Retry letter topic</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Partitioned-topics\"><span class=\"toc-text\">Partitioned topics</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Non-persistent-topics\"><span class=\"toc-text\">Non-persistent topics</span></a></li></ol></li></ol></li></ol>","author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5254061686","zhihu":"","csdn":"","juejin":""}},"mapped":true,"prev_post":{"title":"AWK 样式扫描和处理语言","uid":"0ae44ea2c5de8fc0dba98b172b9416ad","slug":"linux/awk","date":"2021-04-15T10:32:47.000Z","updated":"2022-01-02T16:47:54.074Z","comments":true,"path":"api/articles/linux/awk.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image.6rex2bvab6k0.png","text":"AWK 样式扫描和处理语言简介AWK（其名称得自于它的创始人阿尔佛雷德·艾侯、彼得·温伯格和布莱恩·柯林汉姓氏的首个字母）是一种优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一。AWK提供了极其强大的功能：可以进行正则表达式的匹配，样式装入、流控制...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":14,"path":"api/categories/学习记录.json"}],"tags":[{"name":"Linux","slug":"Linux","count":2,"path":"api/tags/Linux.json"}],"author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5254061686","zhihu":"","csdn":"","juejin":""}}},"next_post":{"title":"软链接&硬链接","uid":"3256cb14c92d99ae1c7a0ab0e2019e03","slug":"linux/软链接&硬链接","date":"2021-03-15T10:32:47.000Z","updated":"2022-01-02T16:47:54.076Z","comments":true,"path":"api/articles/linux/软链接&硬链接.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/149821619272625_.pic_hd.4a5jn7gu5x40.jpg","text":"软链接&amp;硬链接什么是链接？链接简单说实际上是一种文件共享的方式，是 POSIX 中的概念，主流文件系统都支持链接文件。 inode**inode (index node)**是指在许多“类Unix文件系统”中的一种数据结构，用于描述文件系统对象（包括文件、目录、设备文件、...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":14,"path":"api/categories/学习记录.json"}],"tags":[{"name":"Linux","slug":"Linux","count":2,"path":"api/tags/Linux.json"}],"author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5254061686","zhihu":"","csdn":"","juejin":""}}}}