{"title":"Kafka简介","uid":"0602fa7501a658e7531a856a02eb9d8f","slug":"mq/Kafka","date":"2021-03-01T10:32:47.000Z","updated":"2022-01-02T16:47:54.078Z","comments":true,"path":"api/articles/mq/Kafka.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image.6q3gimd5fcg0.png","content":"<h1 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h1><p><img src=\"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image-20210422154314373.1bdeulhndrs0.png\" alt=\"img\"></p>\n<ul>\n<li>Broker：消息中间件处理结点，一个Kafka节点就是一个broker，多个broker可以组成一个Kafka集群</li>\n<li>Topic：一类消息，Kafka集群能够同时负责多个topic的分发</li>\n<li>Partition：topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列</li>\n<li>Segment：partition物理上由多个segment组成</li>\n<li>offset：每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中</li>\n<li>Consumer：消息消费者，向Kafka broker读取消息的客户端</li>\n<li>Consumer Group：每个Consumer属于一个特定的Consumer Group</li>\n</ul>\n<h1 id=\"Kafka消息存储格式\"><a href=\"#Kafka消息存储格式\" class=\"headerlink\" title=\"Kafka消息存储格式\"></a>Kafka消息存储格式</h1><p>在Kafka文件存储中，同一个topic下有多个不同partition，每个partition为一个目录，partiton命名规则为topic名称+有序序号，第一个partiton序号从0开始，序号最大值为partitions数量减1</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/32100636ec0347229b475619f07287ba.50ezw6jsys40.jpeg\" alt=\"img\"></p>\n<ul>\n<li>每个partion（目录）相当于一个巨型文件被平均分配到多个大小相等segment（段）数据文件中</li>\n<li>每个partiton只需要支持顺序读写就行了，segment文件生命周期由服务端配置参数决定</li>\n</ul>\n<h2 id=\"segment\"><a href=\"#segment\" class=\"headerlink\" title=\"segment\"></a><strong>segment</strong></h2><ul>\n<li>segment file组成：由2大部分组成，分别为index file和data file，此2个文件一一对应，成对出现，后缀”.index”和“.log”分别表示为segment索引文件、数据文件</li>\n<li>segment文件命名规则：partion全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后一条消息的offset值。数值最大为64位long大小，19位数字字符长度，没有数字用0填充</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/24b62a45a37a4e70802e5b69c943cce3.1j42d20f1jkw.png\" alt=\"img\"></p>\n<p>索引文件存储大量元数据，数据文件存储大量消息，索引文件中元数据指向对应数据文件中message的物理偏移地址</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/52ed0c5167af4792b291e413cb842bcc.40058wuzphk0.jpeg\" alt=\"img\"></p>\n<p>其中以索引文件中元数据3,497为例，依次在数据文件中表示第3个message（在全局partiton表示第368772个message），以及该消息的物理偏移地址为497</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/630a5fbaac28400bae136ab8731ed7d2.f3qfhpwptuw.jpeg\" alt=\"img\"></p>\n<ul>\n<li>offset：每条消息的有序的id号</li>\n<li>CRC32：用crc32校验message</li>\n<li>magic：Kafka服务程序协议版本号</li>\n<li>attributes：独立版本、或标识压缩类型、或编码类型</li>\n<li>value bytes payload：表示实际消息数据</li>\n</ul>\n<h1 id=\"副本（replication）策略\"><a href=\"#副本（replication）策略\" class=\"headerlink\" title=\"副本（replication）策略\"></a>副本（replication）策略</h1><h2 id=\"1-数据同步\"><a href=\"#1-数据同步\" class=\"headerlink\" title=\"1.数据同步\"></a>1.数据同步</h2><p>同一个Partition可能会有多个Replica，而这时需要在这些Replication之间选出一个Leader，Producer和Consumer只与这个Leader交互，其它Replica作为Follower从Leader中复制数据</p>\n<h2 id=\"2-副本放置策略\"><a href=\"#2-副本放置策略\" class=\"headerlink\" title=\"2.副本放置策略\"></a>2.副本放置策略</h2><ul>\n<li>将所有存活的N个Brokers和待分配的Partition排序</li>\n<li>将第i个Partition分配到第(i mod n)个Broker上，这个Partition的第一个Replica存在于这个分配的Broker上，并且会作为partition的优先副本</li>\n<li>将第i个Partition的第j个Replica分配到第((i + j) mod n)个Broker上</li>\n</ul>\n<h2 id=\"3-同步策略\"><a href=\"#3-同步策略\" class=\"headerlink\" title=\"3.同步策略\"></a>3.同步策略</h2><ol>\n<li>Producer在发布消息到某个Partition的Leader</li>\n<li>Producer只将该消息发送到该Partition的Leader，该消息写入其本地Log</li>\n<li>每个Follower都从Leader pull数据同步</li>\n<li>Follower在收到该消息先向Leader发送ACK再写入其Log后（Kafka只能保证它被存于多个Replica的内存中，而不能保证它们被持久化到磁盘中，也就不能完全保证异常发生后该条消息一定能被Consumer消费）<ul>\n<li>kafka维护了一个ISR（in-sync replicas ），如果一个follower宕机（broker宕机当然算），或者落后太多，leader将把它从”in sync” list中移除</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"4-leader选举\"><a href=\"#4-leader选举\" class=\"headerlink\" title=\"4.leader选举\"></a>4.leader选举</h2><p><strong>kafka0.8.2之前：</strong></p>\n<p>为Partition分配副本，指定一个ZNode临时节点，第一个成功创建节点的副本就是Leader节点，其他副本会在这个ZNode节点上注册Watcher监听器，一旦Leader宕机，对应的临时节点就会被自动删除，这时注册在该节点上的所有Follower都会收到监听器事件，它们都会尝试创建该节点，只有创建成功的那个follower才会成为Leader</p>\n<p><strong>之后：</strong></p>\n<ul>\n<li>整个集群中选举出一个Broker作为Controller</li>\n<li>Controller为所有Topic的所有Partition指定Leader及Follower</li>\n<li>当一个leader宕机，kafka Controller从分区的ISR中选一个作为leader</li>\n</ul>\n<h1 id=\"高吞吐量的几点设计\"><a href=\"#高吞吐量的几点设计\" class=\"headerlink\" title=\"高吞吐量的几点设计\"></a>高吞吐量的几点设计</h1><ol>\n<li><p>顺序写入</p>\n</li>\n<li><p>Page Cache</p>\n</li>\n<li><p>零拷贝技术</p>\n</li>\n<li><p>引入了Partition以及优秀的文件存储</p>\n</li>\n<li><p>Producer向broker push消息，Consumer从broker pull消息</p>\n</li>\n</ol>\n","feature":null,"text":"架构 Broker：消息中间件处理结点，一个Kafka节点就是一个broker，多个broker可以组成一个Kafka集群 Topic：一类消息，Kafka集群能够同时负责多个topic的分发 Partition：topic物理上的分组，一个topic可以分为多个partitio...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":14,"path":"api/categories/学习记录.json"}],"tags":[{"name":"Kafka","slug":"Kafka","count":1,"path":"api/tags/Kafka.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">架构</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Kafka%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">Kafka消息存储格式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#segment\"><span class=\"toc-text\">segment</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%AF%E6%9C%AC%EF%BC%88replication%EF%BC%89%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">副本（replication）策略</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">1.数据同步</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%89%AF%E6%9C%AC%E6%94%BE%E7%BD%AE%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">2.副本放置策略</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">3.同步策略</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-leader%E9%80%89%E4%B8%BE\"><span class=\"toc-text\">4.leader选举</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F%E7%9A%84%E5%87%A0%E7%82%B9%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">高吞吐量的几点设计</span></a></li></ol>","author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":""}},"mapped":true,"prev_post":{"title":"Java内存模型","uid":"33585b12afe7c2c9a6e009942104d7e9","slug":"java/jmm","date":"2021-03-09T10:32:47.000Z","updated":"2022-01-03T13:23:41.059Z","comments":true,"path":"api/articles/java/jmm.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/149071619256095_.pic_hd.pwddlcnxkc0.jpg","text":"简介内存模型描述了程序中各个变量（实例域、静态域和数组元素）之间的关系，以及在实际计算机系统中将变量存储到内存和从内存中取出变量这样的底层细节，对象最终是存储在内存里面的，这点没有错，但是编译器、运行库、处理器或者系统缓存可以有特权在变量指定内存位置存储或者取出变量的值。 【JM...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":14,"path":"api/categories/学习记录.json"}],"tags":[{"name":"Java","slug":"Java","count":3,"path":"api/tags/Java.json"}],"author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":""}}},"next_post":{"title":"Trojan搭建","uid":"f1f87b7aa7ff4eb8772e03523d7680ea","slug":"vps/Trojan一键安装脚本","date":"2021-02-20T10:32:47.000Z","updated":"2022-01-02T16:47:54.093Z","comments":true,"path":"api/articles/vps/Trojan一键安装脚本.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image.269gql6oa2cg.png","text":"Trojan搭建服务端前期准备 系统centos7 /debian9 /ubuntu16以上 域名解析到VPS并生效 一键脚本代码此脚本感谢 atrandys Github项目地址：https://github.com/atrandys/trojan 安装好curl，若是有此环境...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"教程","slug":"教程","count":3,"path":"api/categories/教程.json"}],"tags":[{"name":"vps","slug":"vps","count":1,"path":"api/tags/vps.json"}],"author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":""}}}}