{"title":"Pulsar简介","uid":"6d776fe044c383329f434d8d6568a06a","slug":"mq/pulsar","date":"2021-03-15T10:32:47.000Z","updated":"2022-01-02T16:47:54.079Z","comments":true,"path":"api/articles/mq/pulsar.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image.69iyp6kailo0.png","content":"<h1 id=\"Pulsar简介\"><a href=\"#Pulsar简介\" class=\"headerlink\" title=\"Pulsar简介\"></a>Pulsar简介</h1><p>Apache Pulsar 是灵活的<strong>发布-订阅消息系统</strong>（Flexible Pub/Sub messaging），采用<strong>分层分片架构</strong>。</p>\n<p><strong>特性：</strong></p>\n<ul>\n<li>线性扩展。能够丝滑的扩容到成百上千个节点(Kafka扩容需要占用很多系统资源在节点间拷贝数据，而Plusar完全不用)</li>\n<li>高吞吐。已经在Yahoo的生产环境中经受了考验，每秒数百万消息</li>\n<li>低延迟。在大规模的消息量下依然能够保持低延迟(&lt; 5ms)</li>\n<li>持久化机制。Plusar的持久化机制构建在Apache BookKeeper之上，提供了写与读之间的IO隔离</li>\n<li>基于地理位置的复制。Plusar将多地域/可用区的复制作为首要特性支持。用户只需配置好可用区，消息就会被源源不断的复制到其他可用区。当某一个可用区挂掉或者发生网络分区，plusar会在之后不断的重试。</li>\n<li>部署方式的多样化。既可以运行在裸机，也支持目前例如Docker、K8S的一些容器化方案以及不同的云厂商，同时在本地开发时也只需要一行命令即可启动整个环境。</li>\n<li>Topic支持多种消费模式:exclusive、shared、failover、key_shared</li>\n</ul>\n<h1 id=\"架构概述\"><a href=\"#架构概述\" class=\"headerlink\" title=\"架构概述\"></a>架构概述</h1><p><img src=\"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image.11cn1xusg7k0.png\" alt=\"img\"></p>\n<p>Pulsar采用“存储和服务分离”的两层架构：</p>\n<ul>\n<li>Broker：负责处理和负载均衡 producer 发出的消息，并将这些消息分派给 consumer<ul>\n<li>Pulsar的broker是一个无状态组件</li>\n<li>一个HTTP服务器，它为生产者和使用者公开用于管理任务和主题查找的REST API。生产者连接到代理以发布消息，而消费者连接到代理以使用消息</li>\n<li>一个调度分发器, 它是异步的TCP服务器，通过自定义 <strong>二进制协议</strong>应用于所有相关的数据传输</li>\n</ul>\n</li>\n<li>BookKeeper：负责消息的持久化存储，多个组成Bookie的 集群<ul>\n<li>一个分布式的预写日志（WAL）系统</li>\n<li>能让Pulsar创建多个独立的日志，这种独立的日志就是ledgers. 随着时间的推移，Pulsar会为Topic创建多个ledgers</li>\n<li>保证了多系统挂掉时ledgers的读取一致性</li>\n<li>提供不同的Bookies之间均匀的IO分布的特性</li>\n<li>除了消息数据，<em>cursors</em>（消费端订阅消费的位置）也会被持久化入BookKeeper</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Ledgers\"><a href=\"#Ledgers\" class=\"headerlink\" title=\"Ledgers\"></a>Ledgers</h2><p>ledger是一个只追加的数据结构，并且只有一个写入器，这个写入器负责多个BookKeeper存储节点（就是Bookies）的写入。 Ledger的条目会被复制到多个bookies，Pulsar Broker可以创建ledeger，添加内容到ledger和关闭ledger。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image.613074c7scw0.png\" alt=\"img\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">openLedger(5,3,2)\n5:代表选取五个Bookie节点来记录数据\n3:节点中有多少份备份(write quorum)，同步写\n2:几个节点备份成功算写成功(ack quorum)，假如有读取请求也只会读取ack quorum中的bookie\npulsar中默认为(2,2,2)</code></pre>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image.4em1ig4tjbq0.png\" alt=\"img\"></p>\n<ul>\n<li>Journal WAL（WAL 机制的原理也很简单：修改并不直接写入到数据库文件中，而是写入到另外一个称为WAL 的文件中）<ul>\n<li>概念：数据先入Journal Disks，保障这个盘的<strong>IOPS</strong>有助提高性能</li>\n<li>清理：当 Write Cache 完成 Flush 落盘后自动删除。</li>\n</ul>\n</li>\n<li>Entry Logs<ul>\n<li>概念：真正落盘的日志文件，有序保存不同 ledger 的 entries。</li>\n<li>清理：bookie 后台 GC 线程定期检查其关联的 ledgers 是否在 zk 上已删除，若已删除则自动清理。</li>\n</ul>\n</li>\n<li>Index Files<ul>\n<li>概念：高效顺序写的副作用是，必须在外围维护 <code>(ledger_id, entry_id)</code> 到 <code>Entry_Log</code> 的映射索引，才能实现高效读，故 Flush Cache 时会分离出索引文件。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"容错-amp-扩容\"><a href=\"#容错-amp-扩容\" class=\"headerlink\" title=\"容错&amp;扩容\"></a>容错&amp;扩容</h2><p><strong>Broker挂掉后：</strong></p>\n<ul>\n<li>把对应的ownership挂在到一个可用的broker上<ul>\n<li>其实就是对应zk的节点数据变更</li>\n<li>客户端可能存在一次超时重试</li>\n</ul>\n</li>\n<li>BookKeeper无需任何变动</li>\n</ul>\n<p><strong>Bookie挂掉后：</strong>由于有segment分片副本</p>\n<ul>\n<li>做到了应用无感知</li>\n<li>数据恢复可控（调节健康检查频率、数据恢复的带宽等）</li>\n</ul>\n<p><strong>扩容：</strong>解决了 Kafka 手工扩容、故障恢复慢的问题。</p>\n<ol>\n<li>稳定性可用性高：秒级故障恢复</li>\n<li>水平线性扩容：存储与计算分离，对 Broker 扩容提升读写吞吐，对 Bookie 扩容降低集群负载并提升存储容量。</li>\n<li>扩容负载均衡：Bookie 扩容后新的 ledger 会在新 Bookie 上创建，自动均摊负载。</li>\n</ol>\n","feature":true,"text":"Pulsar简介Apache Pulsar 是灵活的发布-订阅消息系统（Flexible Pub/Sub messaging），采用分层分片架构。 特性： 线性扩展。能够丝滑的扩容到成百上千个节点(Kafka扩容需要占用很多系统资源在节点间拷贝数据，而Plusar完全不用) 高吞...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":14,"path":"api/categories/学习记录.json"}],"tags":[{"name":"Pulsar","slug":"Pulsar","count":2,"path":"api/tags/Pulsar.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Pulsar%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">Pulsar简介</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">架构概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Ledgers\"><span class=\"toc-text\">Ledgers</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E9%94%99-amp-%E6%89%A9%E5%AE%B9\"><span class=\"toc-text\">容错&amp;扩容</span></a></li></ol></li></ol>","author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5254061686","zhihu":"","csdn":"","juejin":""}},"mapped":true,"prev_post":{"title":"软链接&硬链接","uid":"3256cb14c92d99ae1c7a0ab0e2019e03","slug":"linux/软链接&硬链接","date":"2021-03-15T10:32:47.000Z","updated":"2022-01-02T16:47:54.076Z","comments":true,"path":"api/articles/linux/软链接&硬链接.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/149821619272625_.pic_hd.4a5jn7gu5x40.jpg","text":"软链接&amp;硬链接什么是链接？链接简单说实际上是一种文件共享的方式，是 POSIX 中的概念，主流文件系统都支持链接文件。 inode**inode (index node)**是指在许多“类Unix文件系统”中的一种数据结构，用于描述文件系统对象（包括文件、目录、设备文件、...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":14,"path":"api/categories/学习记录.json"}],"tags":[{"name":"Linux","slug":"Linux","count":2,"path":"api/tags/Linux.json"}],"author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5254061686","zhihu":"","csdn":"","juejin":""}}},"next_post":{"title":"Java内存模型","uid":"33585b12afe7c2c9a6e009942104d7e9","slug":"java/jmm","date":"2021-03-09T10:32:47.000Z","updated":"2022-01-03T13:23:41.059Z","comments":true,"path":"api/articles/java/jmm.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/149071619256095_.pic_hd.pwddlcnxkc0.jpg","text":"简介内存模型描述了程序中各个变量（实例域、静态域和数组元素）之间的关系，以及在实际计算机系统中将变量存储到内存和从内存中取出变量这样的底层细节，对象最终是存储在内存里面的，这点没有错，但是编译器、运行库、处理器或者系统缓存可以有特权在变量指定内存位置存储或者取出变量的值。 【JM...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":14,"path":"api/categories/学习记录.json"}],"tags":[{"name":"Java","slug":"Java","count":3,"path":"api/tags/Java.json"}],"author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5254061686","zhihu":"","csdn":"","juejin":""}}}}