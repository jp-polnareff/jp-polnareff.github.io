{"title":"mysql事务","uid":"3520b7e6cac833706ed0bae23ac26e48","slug":"mysql/transaction","date":"2020-01-15T10:32:47.000Z","updated":"2022-01-02T16:47:54.083Z","comments":true,"path":"api/articles/mysql/transaction.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image.6i6i55uqz5c0.png","content":"<h1 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h1><ol>\n<li>READ UNCOMMITED<ol>\n<li>一个事务可以读到其他事务还没提交的数据，会出现脏读</li>\n</ol>\n</li>\n<li>READ COMMITED<ol>\n<li>一个事务只能读到另一个事务修改过的数据，并且其他事务修改提交后能查询到最新值，会出现不可重复读、幻读</li>\n</ol>\n</li>\n<li>REPEATABLE READ<ol>\n<li>一个事务只能读到另一个事务修改过的数据，即使其他事务修改提交后读到的仍是一次的值，会出现幻读</li>\n</ol>\n</li>\n<li>SERIALIZABLE<ol>\n<li>不允许读写并发操作</li>\n</ol>\n</li>\n</ol>\n<span id=\"more\"></span>\n\n<ul>\n<li>脏读<ul>\n<li>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据</li>\n</ul>\n</li>\n<li>不可重复读<ul>\n<li>是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</li>\n</ul>\n</li>\n<li>幻读<ul>\n<li>是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h1><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读</p>\n<ul>\n<li>读-读：不存在任何问题，也不需要并发控制</li>\n<li>读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</li>\n<li>写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</li>\n</ul>\n<h2 id=\"隐藏字段\"><a href=\"#隐藏字段\" class=\"headerlink\" title=\"隐藏字段\"></a>隐藏字段</h2><ul>\n<li>DB_TRX_ID<ul>\n<li>6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID</li>\n</ul>\n</li>\n<li>DB_ROLL_PTR<ul>\n<li>7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</li>\n</ul>\n</li>\n<li>DB_ROW_ID<ul>\n<li> 6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li>\n</ul>\n</li>\n<li>实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了</li>\n</ul>\n<h2 id=\"undo-log\"><a href=\"#undo-log\" class=\"headerlink\" title=\"undo log\"></a>undo log</h2><ul>\n<li>insert undo log<ul>\n<li>代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</li>\n</ul>\n</li>\n<li>update undo log<ul>\n<li> 事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"purge\"><a href=\"#purge\" class=\"headerlink\" title=\"purge\"></a>purge</h3><ul>\n<li>从前面的分析可以看出，为了实现InnoDB的MVCC机制，更新或者删除操作都只是设置一下老记录的deleted_bit，并不真正将过时的记录删除。</li>\n<li>为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的deleted_bit为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。</li>\n</ul>\n<h2 id=\"Read-View-读视图\"><a href=\"#Read-View-读视图\" class=\"headerlink\" title=\"Read View(读视图)\"></a>Read View(读视图)</h2><p>Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。</p>\n<p>Read View遵循一个可见性算法，主要是将要被修改的数据的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果DB_TRX_ID跟Read View的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出Undo Log中的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的DB_TRX_ID, 那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新老版本</p>\n<h3 id=\"三个全局属性\"><a href=\"#三个全局属性\" class=\"headerlink\" title=\"三个全局属性\"></a>三个全局属性</h3><p>trx_list（名字我随便取的）<br> 一个数值列表，用来维护Read View生成时刻系统正活跃的事务ID<br> up_limit_id<br> 记录trx_list列表中事务ID最小的ID<br> low_limit_id<br> ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1</p>\n<ul>\n<li>首先比较DB_TRX_ID &lt; up_limit_id, 如果小于，则当前事务能看到DB_TRX_ID 所在的记录，如果大于等于进入下一个判断</li>\n<li>接下来判断 DB_TRX_ID 大于等于 low_limit_id , 如果大于等于则代表DB_TRX_ID 所在的记录在Read View生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断</li>\n<li>判断DB_TRX_ID 是否在活跃事务之中，trx_list.contains(DB_TRX_ID)，如果在，则代表我Read View生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的；如果不在，则说明，你这个事务在Read View生成之前就已经Commit了，你修改的结果，我当前事务是能看见的</li>\n</ul>\n","feature":null,"text":"隔离级别 READ UNCOMMITED 一个事务可以读到其他事务还没提交的数据，会出现脏读 READ COMMITED 一个事务只能读到另一个事务修改过的数据，并且其他事务修改提交后能查询到最新值，会出现不可重复读、幻读 REPEATABLE READ 一个事务只能读到另一个事...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":14,"path":"api/categories/学习记录.json"}],"tags":[{"name":"Mysql","slug":"Mysql","count":2,"path":"api/tags/Mysql.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB\"><span class=\"toc-text\">隔离级别</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MVCC\"><span class=\"toc-text\">MVCC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">隐藏字段</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#undo-log\"><span class=\"toc-text\">undo log</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#purge\"><span class=\"toc-text\">purge</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Read-View-%E8%AF%BB%E8%A7%86%E5%9B%BE\"><span class=\"toc-text\">Read View(读视图)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E4%B8%AA%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">三个全局属性</span></a></li></ol></li></ol></li></ol>","author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5254061686","zhihu":"","csdn":"","juejin":""}},"mapped":true,"prev_post":{"title":"正则中有特殊字符的问题","uid":"78394d2ce01caa99f662028b4113802c","slug":"question/regex","date":"2020-02-22T10:32:47.000Z","updated":"2022-01-02T16:47:54.088Z","comments":true,"path":"api/articles/question/regex.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image.1yclwqnecnr4.png","text":"正则中有特殊字符的问题String fuzzName &#x3D; &quot;(模糊名称&quot;； Pattern pattern &#x3D; Pattern.compile(&quot;^.*&quot; + fuzzName + &quot;.*$&quot;, Pa...","link":"","photos":[],"count_time":{"symbolsCount":372,"symbolsTime":"1 mins."},"categories":[{"name":"问题记录","slug":"问题记录","count":1,"path":"api/categories/问题记录.json"}],"tags":[{"name":"RegExp","slug":"RegExp","count":1,"path":"api/tags/RegExp.json"}],"author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5254061686","zhihu":"","csdn":"","juejin":""}}},"next_post":{}}