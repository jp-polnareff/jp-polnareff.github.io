{"title":"最近看了看mysql锁总结一波","uid":"7b902ccdd6fada43c870460978ea59ec","slug":"mysql/mysql_lock","date":"2020-01-03T10:32:47.000Z","updated":"2022-01-02T16:47:54.082Z","comments":true,"path":"api/articles/mysql/mysql_lock.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image.5yfldnqvt7k0.png","content":"<h1 id=\"MyISAM表级锁模式：\"><a href=\"#MyISAM表级锁模式：\" class=\"headerlink\" title=\"MyISAM表级锁模式：\"></a><strong>MyISAM表级锁模式：</strong></h1><ul>\n<li><p>表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</p>\n</li>\n<li><p>表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；</p>\n</li>\n</ul>\n<h1 id=\"InnoDB行级锁和表级锁\"><a href=\"#InnoDB行级锁和表级锁\" class=\"headerlink\" title=\"InnoDB行级锁和表级锁\"></a><strong>InnoDB行级锁和表级锁</strong></h1><h2 id=\"InnoDB锁模式：\"><a href=\"#InnoDB锁模式：\" class=\"headerlink\" title=\"InnoDB锁模式：\"></a><strong>InnoDB锁模式：</strong></h2><p>InnoDB 实现了以下两种类型的<strong>行锁</strong>：</p>\n<ul>\n<li><p>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</p>\n</li>\n<li><p>排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</p>\n<span id=\"more\"></span></li>\n</ul>\n<p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是<strong>表锁</strong>：</p>\n<ul>\n<li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li>\n<li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image-20210319114336862-6139083.1dy2ezrr538g.png\" alt=\"img\"></p>\n<h2 id=\"InnoDB加锁方法：\"><a href=\"#InnoDB加锁方法：\" class=\"headerlink\" title=\"InnoDB加锁方法：\"></a><strong>InnoDB加锁方法：</strong></h2><ul>\n<li><p>意向锁是 InnoDB 自动加的， 不需用户干预。</p>\n</li>\n<li><p>对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB<br>会自动给涉及数据集加排他锁（X)；</p>\n</li>\n<li><p>对于普通 SELECT 语句，InnoDB 不会加任何锁；<br>事务可以通过以下语句显式给记录集加共享锁或排他锁：</p>\n</li>\n<li><ul>\n<li>共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。</li>\n<li>排他锁（X)：SELECT * FROM table_name WHERE … FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"InnoDB的间隙锁：\"><a href=\"#InnoDB的间隙锁：\" class=\"headerlink\" title=\"InnoDB的间隙锁：\"></a><strong>InnoDB的间隙锁：</strong></h2><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</p>\n<p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p>\n<p><strong>InnoDB使用间隙锁的目的：</strong></p>\n<ol>\n<li>防止幻读，以满足相关隔离级别的要求；</li>\n<li>满足恢复和复制的需要；</li>\n</ol>\n<h2 id=\"死锁（Deadlock-Free）\"><a href=\"#死锁（Deadlock-Free）\" class=\"headerlink\" title=\"死锁（Deadlock Free）\"></a><strong>死锁（Deadlock Free）</strong></h2><ul>\n<li><p><strong>死锁产生：</strong></p>\n</li>\n<li><ul>\n<li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。</li>\n<li>当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁。</li>\n<li>锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。</li>\n</ul>\n</li>\n<li><p><strong>检测死锁：</strong>数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。</p>\n</li>\n<li><p><strong>死锁恢复：</strong>死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。</p>\n</li>\n<li><p><strong>外部锁的死锁检测：</strong>发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决</p>\n</li>\n<li><p><strong>死锁影响性能：</strong>死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。 有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖innodb_lock_wait_timeout设置进行事务回滚。</p>\n</li>\n</ul>\n","feature":null,"text":"MyISAM表级锁模式： 表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求； 表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作； InnoDB行级锁和表级锁InnoDB锁模式：InnoD...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":14,"path":"api/categories/学习记录.json"}],"tags":[{"name":"Mysql","slug":"Mysql","count":2,"path":"api/tags/Mysql.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MyISAM%E8%A1%A8%E7%BA%A7%E9%94%81%E6%A8%A1%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">MyISAM表级锁模式：</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#InnoDB%E8%A1%8C%E7%BA%A7%E9%94%81%E5%92%8C%E8%A1%A8%E7%BA%A7%E9%94%81\"><span class=\"toc-text\">InnoDB行级锁和表级锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#InnoDB%E9%94%81%E6%A8%A1%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">InnoDB锁模式：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#InnoDB%E5%8A%A0%E9%94%81%E6%96%B9%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">InnoDB加锁方法：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#InnoDB%E7%9A%84%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%9A\"><span class=\"toc-text\">InnoDB的间隙锁：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81%EF%BC%88Deadlock-Free%EF%BC%89\"><span class=\"toc-text\">死锁（Deadlock Free）</span></a></li></ol></li></ol>","author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":""}},"mapped":true,"prev_post":{"title":"mysql事务","uid":"3520b7e6cac833706ed0bae23ac26e48","slug":"mysql/transaction","date":"2020-01-15T10:32:47.000Z","updated":"2022-01-02T16:47:54.083Z","comments":true,"path":"api/articles/mysql/transaction.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image.6i6i55uqz5c0.png","text":"隔离级别 READ UNCOMMITED 一个事务可以读到其他事务还没提交的数据，会出现脏读 READ COMMITED 一个事务只能读到另一个事务修改过的数据，并且其他事务修改提交后能查询到最新值，会出现不可重复读、幻读 REPEATABLE READ 一个事务只能读到另一个事...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":14,"path":"api/categories/学习记录.json"}],"tags":[{"name":"Mysql","slug":"Mysql","count":2,"path":"api/tags/Mysql.json"}],"author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":""}}},"next_post":{}}