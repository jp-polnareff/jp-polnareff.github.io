{"title":"Java内存模型","uid":"33585b12afe7c2c9a6e009942104d7e9","slug":"java/jmm","date":"2021-03-09T10:32:47.000Z","updated":"2022-01-03T13:23:41.059Z","comments":true,"path":"api/articles/java/jmm.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/149071619256095_.pic_hd.pwddlcnxkc0.jpg","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>内存模型描述了程序中各个变量（实例域、静态域和数组元素）之间的关系，以及在实际计算机系统中将变量存储到内存和从内存中取出变量这样的底层细节，对象最终是存储在内存里面的，这点没有错，但是编译器、运行库、处理器或者系统缓存可以有特权在变量指定内存位置存储或者取出变量的值。</p>\n<p>【JMM】（Java Memory Model的缩写）允许编译器和缓存以数据在处理器特定的缓存（或寄存器）和主存之间移动的次序拥有重要的特权，除非程序员使用了<a href=\"https://baike.baidu.com/item/volatile/10606957?fr=aladdin\">volatile</a>或<a href=\"https://baike.baidu.com/item/synchronized/8483356\">synchronized</a>明确请求了某些可见性的保证。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"程序会表现出出人意料的行为\"><a href=\"#程序会表现出出人意料的行为\" class=\"headerlink\" title=\"程序会表现出出人意料的行为\"></a>程序会表现出出人意料的行为</h1><p>Java 的语义允许编译器和微处理器进行优化，这会影响到未正确同步的代码，可能 会使它们的行为看起来自相矛盾。</p>\n<p><strong>例子1：</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image-20210424220422023.1gq0ahedp81s.png\" alt=\"img\"></p>\n<p>程序中用到了局部变量 r1 和 r2，以及共享变量 A 和 B。可能 会出现 r2 == 2、r1 == 1 这样的结果。直觉上，应当要么指令 1 先执行要么指令 3 先执行。如果指令 1 先执行，它不应该能看到指令 4 中写入的值。如果指令 3 先执 行，它不应该能看到指令 2 写的值。</p>\n<p>这段代码没有被充分同步：</p>\n<ul>\n<li>一个线程里有个写操作</li>\n<li>另一个线程读取了这个写入的变量值</li>\n<li>且读写操作没有被同步排序</li>\n</ul>\n<p>当上述情况发生时，称之为存在数据争用（data race），有几种机制都可以产生图 1 中的重排序。JIT 编译器和处理器可以对代码进行重新 整理。此外，运行 JVM 的机器的分级存储系统可以使代码看起来像被重排序过。</p>\n<p><strong>例子2：</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image-20210424220521069.42z2sny1d6a0.png\" alt=\"img\"></p>\n<p>一种常规的编译器优化会在使用 r5 的时候重用 r2：它们读取的都是 r1.x 且它们之 间没有写 r1.x 的操作。</p>\n<p>在线程 1 第一次读取 r1.x 与读取 r3.x 之间，线程 2 对 r6.x 进行了赋值。如果编译器决定在 r5 处重用 r2 的值，那么 r2 和 r5 的值都是 0，r4 的值是 3.从编程人员的角度来看，p.x 的值从 0 变为 3 后又变回了 0。</p>\n<p>理解一个程序是否被正确的同步了，有两个关键概念：<strong>冲突访问</strong>（对同一个共享字段或数组元素存在两个访问（读 或写），且至少有一个访问是写操作，就称作有冲突）和<strong>Happens-Before</strong></p>\n<h1 id=\"Happens-Before\"><a href=\"#Happens-Before\" class=\"headerlink\" title=\"Happens-Before\"></a>Happens-Before</h1><p>两个动作（action）可以被 happens-before 关系排序。如果一 个动作 happens-before 另一个动作，则第一个对第二个可见，且第一个排在第二个之前。</p>\n<p><strong>happens-before 规则</strong>：</p>\n<ul>\n<li>某个线程中的每个动作都 happens-before 该线程中该动作后面的动作。</li>\n<li>某个管程上的 unlock 动作 happens-before 同一个管程上后续的 lock 动作。</li>\n<li>对某个volatile 字段的写操作 happens-before 每个后续对该 volatile 字段的读 操作。 </li>\n<li>在某个线程对象上调用 start()方法 happens-before 该启动了的线程中的任意 动作。</li>\n<li>某个线程中的所有动作 happens-before 任意其它线程成功从该线程对象上的 join()中返回。</li>\n<li>如果某个动作 a happens-before 动作 b，且 b happens-before 动作 c，则有 a happens-before c.</li>\n</ul>\n<p><strong>顺序一致性</strong></p>\n<p>顺序一致性是程序执行过程中可见性和顺序的强有力保证。在顺序一致的执行过程 中，所有动作（如读和写）间存在一个全序关系，与程序的顺序一致。每个动作都是原子的且立即对所有线程可见。如果一个程序没有数据争用，那么该 程序的执行看起来将是顺序一致的。如果将顺序一致性作为内存模型，之前讨论的一些编译器和处理器优化将不再合法。</p>\n<p><strong>final 字段</strong></p>\n<p>final 字段也允许编程人员在不需要同步的情况下实现线程安全的不可变对象。一个线程安全的不可变对象被所有线程都视为不可变的，即使不可变对象的引用在线程间传递时存在数据争用。这提供了安全保证，可以防止不正确或恶意代码误用了不可变类。</p>\n<h1 id=\"synchronizes-with\"><a href=\"#synchronizes-with\" class=\"headerlink\" title=\"synchronizes-with\"></a>synchronizes-with</h1><p>简单来说，synchronizes-with关系是用来确保happen-before关系的，即发生在不同线程间的同步关系，A synchronized B时，表示如果A先于B执行，那么A的执行结果对B一定可见。</p>\n<p>包括：</p>\n<ul>\n<li>某个管程 m 上的解锁动作 synchronizes-with 所有后续在 m 上的锁定动作 。 </li>\n<li>对 volatile 变量 v 的写操作 synchronizes-with 所有后续任意线程对 v 的读操作。</li>\n<li>用于启动一个线程的动作 synchronizes-with 该新启动线程中的第一个动作。线程 T1 的最后一个动作 synchronizes-with 线程 T2 中任一用于探测 T1 是否终止的动作。T2 可能通过调用 T1.isAlive()或者在 T1 上执行一个 join 动作来达到这个目的。</li>\n<li>如果线程 T1 中断了线程 T2，T1 的中断操作 synchronizes-with 任意时刻任 何其它线程（包括 T2）用于确定 T2 是否被中断的操作。这可以通过抛出 一个 InterruptedException 或调用 Thread.interrupted 与 Thread.isInterrupted 来实现。</li>\n<li>为每个变量写默认值（0，false 或 null）的动作 synchronizes-with 每个线程 中的第一个动作。</li>\n<li>调用对象的终结方法时，会隐式的读取该对象的引用。</li>\n</ul>\n<h1 id=\"Java-内存模型的近似模型\"><a href=\"#Java-内存模型的近似模型\" class=\"headerlink\" title=\"Java 内存模型的近似模型\"></a>Java 内存模型的近似模型</h1><h2 id=\"顺序一致的内存模型\"><a href=\"#顺序一致的内存模型\" class=\"headerlink\" title=\"顺序一致的内存模型\"></a>顺序一致的内存模型</h2><p>它太严格了，不适合做 Java 内存模型，因为它 禁止了标准的编译器和处理器优化。</p>\n<h2 id=\"Happens-Before-内存模型\"><a href=\"#Happens-Before-内存模型\" class=\"headerlink\" title=\"Happens-Before 内存模型\"></a>Happens-Before 内存模型</h2><p> happens-before 内存模型，这个模型已经非常接近 Java内存模型的需求，但是，它太弱了；其允许<strong>违反因果关系</strong>这种不可接受的事情发生。</p>\n<h2 id=\"Java-内存模型的正式规范\"><a href=\"#Java-内存模型的正式规范\" class=\"headerlink\" title=\"Java 内存模型的正式规范\"></a>Java 内存模型的正式规范</h2><ul>\n<li>动作与执行过程<ul>\n<li>外部动作</li>\n<li>线程分散（thread divergence）动作</li>\n<li>定义<ul>\n<li>synchronizes-with 的定义</li>\n<li>happens-before 的定义</li>\n<li>充分的同步边缘（suffcient synchronization edges）的定义</li>\n<li>偏序和函数的限制（ Restrictions of partial orders and functions）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>良构的（ Well-Formed）执行过程<ul>\n<li>.每个对变量 x 的读都能看到一个对 x 的写</li>\n<li>同步顺序与程序顺序以及互斥是一致的</li>\n<li>线程的运行遵守线程内（intra-thread）一致性</li>\n<li>线程的运行遵守同步顺序一致性</li>\n<li>线程的运行遵守 happens-before 一致性</li>\n</ul>\n</li>\n<li>执行过程的因果（Causality）要求</li>\n<li>可观察的行为与不会终止的执行过程</li>\n</ul>\n<h1 id=\"8种原子操作\"><a href=\"#8种原子操作\" class=\"headerlink\" title=\"8种原子操作\"></a>8种原子操作</h1><ol>\n<li>lock:将一个变量标识为被一个线程独占状态</li>\n<li>unclock:将一个变量从独占状态释放出来，释放后的变量才可以被其他线程锁定</li>\n<li>read:将一个变量的值从主内存传输到工作内存中，以便随后的load操作</li>\n<li>load:把read操作从主内存中得到的变量值放入工作内存的变量的副本中</li>\n<li>use:把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个使用到变量的指令时都会使用该指令</li>\n<li>assign:把一个从执行引擎接收到的值赋给工作内存中的变量，每当虚拟机遇到一个给变量赋值的指令时，都要使用该操作</li>\n<li>store:把工作内存中的一个变量的值传递给主内存，以便随后的write操作</li>\n<li>write:把store操作从工作内存中得到的变量的值写到主内存中的变量</li>\n</ol>\n<h1 id=\"为什么对long的操作不是原子的？\"><a href=\"#为什么对long的操作不是原子的？\" class=\"headerlink\" title=\"为什么对long的操作不是原子的？\"></a>为什么对long的操作不是原子的？</h1><p>某些 JavaTM 实现可能发现将对 64 位 long 或 double 值的写操作分成两次相邻的 32 位值写操作更方便。</p>\n<p>在64位的环境下，long和double的读写都是是原子操作。</p>\n","feature":null,"text":"简介内存模型描述了程序中各个变量（实例域、静态域和数组元素）之间的关系，以及在实际计算机系统中将变量存储到内存和从内存中取出变量这样的底层细节，对象最终是存储在内存里面的，这点没有错，但是编译器、运行库、处理器或者系统缓存可以有特权在变量指定内存位置存储或者取出变量的值。 【JM...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":14,"path":"api/categories/学习记录.json"}],"tags":[{"name":"Java","slug":"Java","count":3,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">简介</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E4%BC%9A%E8%A1%A8%E7%8E%B0%E5%87%BA%E5%87%BA%E4%BA%BA%E6%84%8F%E6%96%99%E7%9A%84%E8%A1%8C%E4%B8%BA\"><span class=\"toc-text\">程序会表现出出人意料的行为</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Happens-Before\"><span class=\"toc-text\">Happens-Before</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#synchronizes-with\"><span class=\"toc-text\">synchronizes-with</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%BF%91%E4%BC%BC%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">Java 内存模型的近似模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">顺序一致的内存模型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Happens-Before-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">Happens-Before 内存模型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%AD%A3%E5%BC%8F%E8%A7%84%E8%8C%83\"><span class=\"toc-text\">Java 内存模型的正式规范</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#8%E7%A7%8D%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">8种原子操作</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AF%B9long%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%8D%E6%98%AF%E5%8E%9F%E5%AD%90%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">为什么对long的操作不是原子的？</span></a></li></ol>","author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5254061686","zhihu":"","csdn":"","juejin":""}},"mapped":true,"prev_post":{"title":"Pulsar简介","uid":"6d776fe044c383329f434d8d6568a06a","slug":"mq/pulsar","date":"2021-03-15T10:32:47.000Z","updated":"2022-01-02T16:47:54.079Z","comments":true,"path":"api/articles/mq/pulsar.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image.69iyp6kailo0.png","text":"Pulsar简介Apache Pulsar 是灵活的发布-订阅消息系统（Flexible Pub/Sub messaging），采用分层分片架构。 特性： 线性扩展。能够丝滑的扩容到成百上千个节点(Kafka扩容需要占用很多系统资源在节点间拷贝数据，而Plusar完全不用) 高吞...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":14,"path":"api/categories/学习记录.json"}],"tags":[{"name":"Pulsar","slug":"Pulsar","count":2,"path":"api/tags/Pulsar.json"}],"author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5254061686","zhihu":"","csdn":"","juejin":""}}},"next_post":{"title":"Kafka简介","uid":"0602fa7501a658e7531a856a02eb9d8f","slug":"mq/Kafka","date":"2021-03-01T10:32:47.000Z","updated":"2022-01-02T16:47:54.078Z","comments":true,"path":"api/articles/mq/Kafka.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image.6q3gimd5fcg0.png","text":"架构 Broker：消息中间件处理结点，一个Kafka节点就是一个broker，多个broker可以组成一个Kafka集群 Topic：一类消息，Kafka集群能够同时负责多个topic的分发 Partition：topic物理上的分组，一个topic可以分为多个partitio...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":14,"path":"api/categories/学习记录.json"}],"tags":[{"name":"Kafka","slug":"Kafka","count":1,"path":"api/tags/Kafka.json"}],"author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5254061686","zhihu":"","csdn":"","juejin":""}}}}