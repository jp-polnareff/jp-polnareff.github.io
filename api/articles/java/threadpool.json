{"title":"线程池总结","uid":"6199f8896169806e8b51dc181ed51cca","slug":"java/threadpool","date":"2020-06-29T10:32:47.000Z","updated":"2022-01-03T13:23:44.755Z","comments":true,"path":"api/articles/java/threadpool.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/149081619256095_.pic_hd.3gam3xte6me0.jpg","content":"<h1 id=\"七大参数\"><a href=\"#七大参数\" class=\"headerlink\" title=\"七大参数\"></a>七大参数</h1><ol>\n<li>corePoolSize 线程池核心线程大小</li>\n<li>maximumPoolSize 线程池最大线程数量</li>\n<li>keepAliveTime 空闲线程存活时间</li>\n<li>unit 空间线程存活时间单位</li>\n<li>workQueue 工作队列</li>\n<li>threadFactory 线程工厂<ol>\n<li>创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等</li>\n</ol>\n</li>\n<li>handler 拒绝策略</li>\n</ol>\n<span id=\"more\"></span>\n\n<h2 id=\"workQueue\"><a href=\"#workQueue\" class=\"headerlink\" title=\"workQueue\"></a>workQueue</h2><p>新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列：</p>\n<p>①ArrayBlockingQueue</p>\n<p>基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。</p>\n<p>②LinkedBlockingQuene</p>\n<p>基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而不会去创建新线程直到maxPoolSize，因此使用该工作队列时，参数maxPoolSize其实是不起作用的。</p>\n<p>③SynchronousQuene</p>\n<p>一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。</p>\n<p>④PriorityBlockingQueue</p>\n<p>具有优先级的无界阻塞队列，优先级通过参数Comparator实现。</p>\n<h2 id=\"handler\"><a href=\"#handler\" class=\"headerlink\" title=\"handler\"></a>handler</h2><p>①CallerRunsPolicy</p>\n<p>在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。</p>\n<p>②AbortPolicy</p>\n<p>直接丢弃任务，并抛出RejectedExecutionException异常。</p>\n<p> ③DiscardPolicy</p>\n<p>直接丢弃任务，什么都不做。</p>\n<p>④DiscardOldestPolicy</p>\n<p>抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列</p>\n<h3 id=\"实现-RejectedExecutionHandler-接口扩展\"><a href=\"#实现-RejectedExecutionHandler-接口扩展\" class=\"headerlink\" title=\"实现 RejectedExecutionHandler 接口扩展\"></a>实现 RejectedExecutionHandler 接口扩展</h3><p>netty自己实现的线程池里面私有的一个拒绝策略。单独启动一个新的临时线程来执行任务。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static final class NewThreadRunsPolicy implements RejectedExecutionHandler &#123;\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123;\n            try &#123;\n                final Thread t &#x3D; new Thread(r, &quot;Temporary task executor&quot;);\n                t.start();\n            &#125; catch (Throwable e) &#123;\n                throw new RejectedExecutionException(\n                        &quot;Failed to start a new thread&quot;, e);\n            &#125;\n        &#125;\n    &#125;</code></pre>\n\n<p>个是dubbo的一个例子，它直接继承的 AbortPolicy ，加强了日志输出，并且输出dump文件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AbortPolicyWithReport extends ThreadPoolExecutor.AbortPolicy &#123;\n\n    @Override\n    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;\n        String msg &#x3D; String.format(&quot;Thread pool is EXHAUSTED!&quot; +\n                        &quot; Thread Name: %s, Pool Size: %d (active: %d, core: %d, max: %d, largest: %d), Task: %d (completed: %d),&quot; +\n                        &quot; Executor status:(isShutdown:%s, isTerminated:%s, isTerminating:%s), in %s:&#x2F;&#x2F;%s:%d!&quot;,\n                threadName, e.getPoolSize(), e.getActiveCount(), e.getCorePoolSize(), e.getMaximumPoolSize(), e.getLargestPoolSize(),\n                e.getTaskCount(), e.getCompletedTaskCount(), e.isShutdown(), e.isTerminated(), e.isTerminating(),\n                url.getProtocol(), url.getIp(), url.getPort());\n        logger.warn(msg);\n        dumpJStack();\n        throw new RejectedExecutionException(msg);\n    &#125;\n&#125;</code></pre>\n\n<h1 id=\"四种常见的线程池\"><a href=\"#四种常见的线程池\" class=\"headerlink\" title=\"四种常见的线程池\"></a>四种常见的线程池</h1><h2 id=\"CachedThreadPool\"><a href=\"#CachedThreadPool\" class=\"headerlink\" title=\"CachedThreadPool\"></a>CachedThreadPool</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static ExecutorService newCachedThreadPool() &#123;\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue&lt;Runnable&gt;());\n&#125;</code></pre>\n\n<h2 id=\"SecudleThreadPool\"><a href=\"#SecudleThreadPool\" class=\"headerlink\" title=\"SecudleThreadPool\"></a>SecudleThreadPool</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;\n    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n          new DelayedWorkQueue());\n&#125;</code></pre>\n\n<h2 id=\"SingleThreadPool\"><a href=\"#SingleThreadPool\" class=\"headerlink\" title=\"SingleThreadPool\"></a>SingleThreadPool</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static ExecutorService newSingleThreadExecutor() &#123;\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue&lt;Runnable&gt;()));\n&#125;</code></pre>\n\n<h2 id=\"FixedThreadPool\"><a href=\"#FixedThreadPool\" class=\"headerlink\" title=\"FixedThreadPool\"></a>FixedThreadPool</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static ExecutorService newFixedThreadPool(int nThreads) &#123;\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue&lt;Runnable&gt;());\n&#125;</code></pre>\n\n<h1 id=\"线程提交优先级\"><a href=\"#线程提交优先级\" class=\"headerlink\" title=\"线程提交优先级\"></a>线程提交优先级</h1><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int c &#x3D; ctl.get();\n&#x2F;&#x2F; 小于核心数，核心线程处理\nif (workerCountOf(c) &lt; corePoolSize) &#123;\n    if (addWorker(command, true))\n        return;\n    c &#x3D; ctl.get();\n&#125;\n&#x2F;&#x2F; 大于核心放队列\nif (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;\n    int recheck &#x3D; ctl.get();\n    if (! isRunning(recheck) &amp;&amp; remove(command))\n        reject(command);\n    else if (workerCountOf(recheck) &#x3D;&#x3D; 0)\n        addWorker(null, false);\n&#125;\n&#x2F;&#x2F;核心数队列满 非核心线程\nelse if (!addWorker(command, false))\n\t\t&#x2F;&#x2F; 拒绝策略\n    reject(command);</code></pre>\n\n<h1 id=\"execute-amp-submit区别\"><a href=\"#execute-amp-submit区别\" class=\"headerlink\" title=\"execute&amp;submit区别\"></a>execute&amp;submit区别</h1><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Future&lt;?&gt; submit(Runnable task) &#123;\n    if (task &#x3D;&#x3D; null) throw new NullPointerException();\n    RunnableFuture&lt;Void&gt; ftask &#x3D; newTaskFor(task, null);\n    execute(ftask);\n    return ftask;\n&#125;</code></pre>\n\n<ol>\n<li>execute和submit都属于线程池的方法，execute只能提交Runnable类型的任务，而submit既能提交Runnable类型任务也能提交Callable类型任务。</li>\n<li>execute会直接抛出任务执行时的异常，submit会吃掉异常，可通过Future的get方法将任务执行时的异常重新抛出。</li>\n<li>execute所属顶层接口是Executor,submit所属顶层接口是ExecutorService，实现类ThreadPoolExecutor重写了execute方法,抽象类AbstractExecutorService重写了submit方法。</li>\n<li>submit也是调用的excute</li>\n</ol>\n<h1 id=\"execute流程\"><a href=\"#execute流程\" class=\"headerlink\" title=\"execute流程\"></a>execute流程</h1><p><img src=\"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image-20210317175704204.1kmpo8rsxkbk.png\" alt=\"img\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image-20210317175743694.6ebkkdci0mk0.png\" alt=\"img\"></p>\n","feature":null,"text":"七大参数 corePoolSize 线程池核心线程大小 maximumPoolSize 线程池最大线程数量 keepAliveTime 空闲线程存活时间 unit 空间线程存活时间单位 workQueue 工作队列 threadFactory 线程工厂 创建一个新线程时使用的工厂...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":14,"path":"api/categories/学习记录.json"}],"tags":[{"name":"Java","slug":"Java","count":3,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%83%E5%A4%A7%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">七大参数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#workQueue\"><span class=\"toc-text\">workQueue</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#handler\"><span class=\"toc-text\">handler</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0-RejectedExecutionHandler-%E6%8E%A5%E5%8F%A3%E6%89%A9%E5%B1%95\"><span class=\"toc-text\">实现 RejectedExecutionHandler 接口扩展</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span class=\"toc-text\">四种常见的线程池</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CachedThreadPool\"><span class=\"toc-text\">CachedThreadPool</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SecudleThreadPool\"><span class=\"toc-text\">SecudleThreadPool</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SingleThreadPool\"><span class=\"toc-text\">SingleThreadPool</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#FixedThreadPool\"><span class=\"toc-text\">FixedThreadPool</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E6%8F%90%E4%BA%A4%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">线程提交优先级</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#execute-amp-submit%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">execute&amp;submit区别</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#execute%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">execute流程</span></a></li></ol>","author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":""}},"mapped":true,"prev_post":{"title":"SDS 简单动态字符串","uid":"dd327c2a75c4b810517d5dca0d9f2612","slug":"redis/sds","date":"2020-08-12T10:32:47.000Z","updated":"2022-01-02T16:47:54.089Z","comments":true,"path":"api/articles/redis/sds.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/148881619190256_.pic_hd.2uocrn36h4g0.jpg","text":"SDS 简单动态字符串（simple dynamic string）Redis 没有直接使用C语言传统的字符串表示，而是自己构建了一种名为简单动态字符串（simple dynamic string SDS）的抽象类型，并将SDS用作Redis 的默认字符串表示。 SDS定义str...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":14,"path":"api/categories/学习记录.json"}],"tags":[{"name":"Redis","slug":"Redis","count":1,"path":"api/tags/Redis.json"}],"author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":""}}},"next_post":{"title":"网络学习记录","uid":"238fe05c72e7ef06b8187b847de369e2","slug":"network/netbase","date":"2020-06-13T10:32:47.000Z","updated":"2022-01-02T16:47:54.086Z","comments":true,"path":"api/articles/network/netbase.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image.18zcs0vcfsf4.png","text":"OSI层参考模型&amp;TCP/IP参考模型 IP 4位版本：0x4指IPv4 4位首部长度（5-15）：指明IPv4协议包头长度的字节数包含多少个32位，IPv4包头的最小长度是20个字节，最长为60个字节。 服务类型：前3位优先权字段包的重要性，最后1位未用位必须为0 中间...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":14,"path":"api/categories/学习记录.json"}],"tags":[{"name":"Network","slug":"Network","count":1,"path":"api/tags/Network.json"}],"author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":""}}}}