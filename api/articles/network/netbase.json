{"title":"网络学习记录","uid":"238fe05c72e7ef06b8187b847de369e2","slug":"network/netbase","date":"2020-06-13T10:32:47.000Z","updated":"2022-01-02T16:47:54.086Z","comments":true,"path":"api/articles/network/netbase.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image.18zcs0vcfsf4.png","content":"<h1 id=\"OSI层参考模型-amp-TCP-IP参考模型\"><a href=\"#OSI层参考模型-amp-TCP-IP参考模型\" class=\"headerlink\" title=\"OSI层参考模型&amp;TCP/IP参考模型\"></a>OSI层参考模型&amp;TCP/IP参考模型</h1><div align=\"center\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/4fa11aa9cea1bdfbca629e5376d9af89-8486625.1owbetttwuhs.png\" alt=\"img\"></p>\n</div>\n\n<span id=\"more\"></span>\n\n\n\n<h1 id=\"IP\"><a href=\"#IP\" class=\"headerlink\" title=\"IP\"></a>IP</h1><p><img src=\"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/Center.30lbynwrq940.png\" alt=\"img\"></p>\n<ul>\n<li>4位版本：0x4指IPv4</li>\n<li>4位首部长度（5-15）：指明IPv4协议包头长度的字节数包含多少个32位，IPv4包头的最小长度是20个字节，最长为60个字节。</li>\n<li>服务类型：前3位优先权字段包的重要性，最后1位未用位必须为0<ul>\n<li>中间四位 （分别代表最小延时、最大吞吐量、最高可靠性、最小费用）</li>\n</ul>\n</li>\n<li>16位总长度：ip包的总长度单位字节</li>\n<li>16位标识：由上一层来决定（udp、tcp），ip封包重组</li>\n<li>3位标志：df｜mf｜没用<ul>\n<li>df：不分段丢包</li>\n<li>mf：更多分段，0该封包是最後一个封包,1其後还有被分割的封包｡</li>\n</ul>\n</li>\n<li>13位分段偏移：封包进行分段的时候会为各片段做好定位记录,以便在重组的时候就能够对号入座｡</li>\n<li>8位生存时间（ttl）：一旦经过一个处理它的路由器,它的值就减去1｡当该字段的值为0时,数据报就被丢弃,并发送ICMP消息通知源主机｡可以预防环路</li>\n<li>8位协议：<ul>\n<li>01：icmp</li>\n<li>06：tcp</li>\n<li>17：udp</li>\n</ul>\n</li>\n<li>16位首部校验和：首部检验和字段是根据IP首部计算的检验和码,不对首部后面的数据进行计算｡</li>\n</ul>\n<h1 id=\"ARP\"><a href=\"#ARP\" class=\"headerlink\" title=\"ARP\"></a>ARP</h1><p>ARP协议是“Address Resolution Protocol”（地址解析协议）的缩写。其作用是在以太网环境中，数据的传输所依懒的是MAC地址而非IP地址，而将已知IP地址转换为MAC地址的工作是由ARP协议来完成的。</p>\n<p><a href=\"https://blog.csdn.net/jiejiemcu/article/details/88406088\">https://blog.csdn.net/jiejiemcu/article/details/88406088</a></p>\n<p><a href=\"https://www.cnblogs.com/csguo/p/7527303.html\">https://www.cnblogs.com/csguo/p/7527303.html</a></p>\n<p>ARP请求是广播，响应时单播</p>\n<h2 id=\"ARP分组格式\"><a href=\"#ARP分组格式\" class=\"headerlink\" title=\"ARP分组格式\"></a>ARP分组格式</h2><p><img src=\"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/format,png.6vzcpxu320c0.png\" alt=\"img\"></p>\n<h1 id=\"ICMP\"><a href=\"#ICMP\" class=\"headerlink\" title=\"ICMP\"></a>ICMP</h1><p>在RFC，将ICMP 大致分成两种功能：差错通知和信息查询。</p>\n<p><a href=\"https://www.cnblogs.com/iiiiher/p/8513748.html\">https://www.cnblogs.com/iiiiher/p/8513748.html</a></p>\n<h1 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h1><p><img src=\"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image-20210313154346306.6rtorq8ff1g0.png\" alt=\"img\"></p>\n<p>32位序号：seq</p>\n<p>32位确认序号：ack</p>\n<p>4位首部长度：4位包括TCP头大小，指示何处数据开始。</p>\n<p>保留（6位）：6位值域，这些位必须是0。为了将来定义新的用途而保留。</p>\n<p>标志：6位标志域。表示为：紧急标志、有意义的应答标志、推、重置连接标志、同步序列号标志、完成发送数据标志。按照顺序排列是：URG、ACK、PSH、RST、SYN、FIN。</p>\n<p>16位窗口大小：用来表示想收到的每个TCP数据段的大小。TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。窗口大小是一个16字节字段，因而窗口大小最大为65535字节。</p>\n<p>16位校验和：16位TCP头。源机器基于数据内容计算一个数值，收信息机要与源机器数值 结果完全一样，从而证明数据的有效性。检验和覆盖了整个的TCP报文段：这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证的。</p>\n<p>16位紧急指针：指向后面是优先数据的字节，在URG标志设置了时才有效。如果URG标志没有被设置，紧急域作为填充。加快处理标示为紧急的数据段。</p>\n<h2 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h2><p><img src=\"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image-20210313154834366.8wpobbe1ykg.png\" alt=\"img\"></p>\n<h3 id=\"SYN攻击\"><a href=\"#SYN攻击\" class=\"headerlink\" title=\"SYN攻击\"></a><strong>SYN攻击</strong></h3><p>在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击。</p>\n<h2 id=\"TCP四次挥手\"><a href=\"#TCP四次挥手\" class=\"headerlink\" title=\"TCP四次挥手\"></a>TCP四次挥手</h2><p><img src=\"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image.1poh73ouul5s.png\" alt=\"img\"></p>\n<h3 id=\"为什么四次挥手？\"><a href=\"#为什么四次挥手？\" class=\"headerlink\" title=\"为什么四次挥手？\"></a>为什么四次挥手？</h3><p>TCP是一个全双工协议，必须单独拆除每一条信道，确保数据能够完成传输；</p>\n<p>当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了。</p>\n<h3 id=\"为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？\"><a href=\"#为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？\" class=\"headerlink\" title=\"为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？\"></a>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</h3><p>原因有二：<br> 一、保证TCP协议的全双工连接能够可靠关闭<br> 二、保证这次连接的重复数据段从网络中消失</p>\n<p>先说第一点，如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。</p>\n<p>再说第二点，如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</p>\n<h2 id=\"超时和重传\"><a href=\"#超时和重传\" class=\"headerlink\" title=\"超时和重传\"></a>超时和重传</h2><ul>\n<li>TCP使用四种定时器（Timer，也称为“计时器”）：<ul>\n<li>重传计时器：Retransmission Timer<ul>\n<li>重传时间=2*RTT（往返时延）；</li>\n</ul>\n</li>\n<li>坚持计时器：Persistent Timer</li>\n<li>保活计时器：Keeplive Timer<ul>\n<li>超时通常设置2小时，若服务器超过2小时还没有收到来自客户的信息，就发送探测报文段，若发送了10个探测报文段（每75秒发送一个）还没收到响应，则终止连接。</li>\n</ul>\n</li>\n<li>时间等待计时（2MSL）器：Time_Wait Timer</li>\n</ul>\n</li>\n</ul>\n","feature":true,"text":"OSI层参考模型&amp;TCP/IP参考模型 IP 4位版本：0x4指IPv4 4位首部长度（5-15）：指明IPv4协议包头长度的字节数包含多少个32位，IPv4包头的最小长度是20个字节，最长为60个字节。 服务类型：前3位优先权字段包的重要性，最后1位未用位必须为0 中间...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":14,"path":"api/categories/学习记录.json"}],"tags":[{"name":"Network","slug":"Network","count":1,"path":"api/tags/Network.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#OSI%E5%B1%82%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B-amp-TCP-IP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">OSI层参考模型&amp;TCP&#x2F;IP参考模型</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#IP\"><span class=\"toc-text\">IP</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ARP\"><span class=\"toc-text\">ARP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ARP%E5%88%86%E7%BB%84%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">ARP分组格式</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ICMP\"><span class=\"toc-text\">ICMP</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#TCP\"><span class=\"toc-text\">TCP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B\"><span class=\"toc-text\">三次握手</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SYN%E6%94%BB%E5%87%BB\"><span class=\"toc-text\">SYN攻击</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\"><span class=\"toc-text\">TCP四次挥手</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F\"><span class=\"toc-text\">为什么四次挥手？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88TIME-WAIT%E7%8A%B6%E6%80%81%E9%9C%80%E8%A6%81%E7%BB%8F%E8%BF%872MSL-%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E6%AE%B5%E7%94%9F%E5%AD%98%E6%97%B6%E9%97%B4-%E6%89%8D%E8%83%BD%E8%BF%94%E5%9B%9E%E5%88%B0CLOSE%E7%8A%B6%E6%80%81%EF%BC%9F\"><span class=\"toc-text\">为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B6%85%E6%97%B6%E5%92%8C%E9%87%8D%E4%BC%A0\"><span class=\"toc-text\">超时和重传</span></a></li></ol></li></ol>","author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":""}},"mapped":true,"prev_post":{"title":"线程池总结","uid":"6199f8896169806e8b51dc181ed51cca","slug":"java/threadpool","date":"2020-06-29T10:32:47.000Z","updated":"2022-01-03T13:23:44.755Z","comments":true,"path":"api/articles/java/threadpool.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/149081619256095_.pic_hd.3gam3xte6me0.jpg","text":"七大参数 corePoolSize 线程池核心线程大小 maximumPoolSize 线程池最大线程数量 keepAliveTime 空闲线程存活时间 unit 空间线程存活时间单位 workQueue 工作队列 threadFactory 线程工厂 创建一个新线程时使用的工厂...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":14,"path":"api/categories/学习记录.json"}],"tags":[{"name":"Java","slug":"Java","count":3,"path":"api/tags/Java.json"}],"author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":""}}},"next_post":{"title":"Stream流中flatMap","uid":"aa78a5b1d7c1c5eaa46eb8f528b149b8","slug":"java/flatMap","date":"2020-06-11T10:32:47.000Z","updated":"2022-01-02T16:47:54.070Z","comments":true,"path":"api/articles/java/flatMap.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image.2zu0whan4ai.png","text":"Stream流中flatMapflatMap操作的作用是对流的元素进行一对多转换，然后将生成的元素展平到新的流中。 &#x2F;&#x2F; 假如我们想把ll打平到一个List&lt;String&gt;中？ List&lt;List&lt;String&gt;&gt; ll &...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":14,"path":"api/categories/学习记录.json"}],"tags":[{"name":"Java","slug":"Java","count":3,"path":"api/tags/Java.json"}],"author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":""}}}}