{"title":"SDS 简单动态字符串","uid":"dd327c2a75c4b810517d5dca0d9f2612","slug":"redis/sds","date":"2020-08-12T10:32:47.000Z","updated":"2022-01-02T16:47:54.089Z","comments":true,"path":"api/articles/redis/sds.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/148881619190256_.pic_hd.2uocrn36h4g0.jpg","content":"<h1 id=\"SDS-简单动态字符串（simple-dynamic-string）\"><a href=\"#SDS-简单动态字符串（simple-dynamic-string）\" class=\"headerlink\" title=\"SDS 简单动态字符串（simple dynamic string）\"></a>SDS 简单动态字符串（simple dynamic string）</h1><p>Redis 没有直接使用C语言传统的字符串表示，而是自己构建了一种名为简单动态字符串（simple dynamic string SDS）的抽象类型，并将SDS用作Redis 的默认字符串表示。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"SDS定义\"><a href=\"#SDS定义\" class=\"headerlink\" title=\"SDS定义\"></a>SDS定义</h2><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">struct sdshdr &#123;\n  \n      int len;\n  \n      int free;\n  \n      char buf[];\n&#125;;</code></pre>\n\n<ul>\n<li><p>len:：表示SDS保存字符串长度</p>\n</li>\n<li><p>free：表示SDS还未分配使用的空间</p>\n</li>\n<li><p>buf：保存字符串，最后一个保存空字符’\\0’</p>\n</li>\n</ul>\n<h2 id=\"SDS与C字符串区别\"><a href=\"#SDS与C字符串区别\" class=\"headerlink\" title=\"SDS与C字符串区别\"></a>SDS与C字符串区别</h2><h3 id=\"1-常数复杂度获取字符串长度\"><a href=\"#1-常数复杂度获取字符串长度\" class=\"headerlink\" title=\"1.常数复杂度获取字符串长度\"></a>1.常数复杂度获取字符串长度</h3><p>C 字符串并不记录自身的长度信息， 所以为了获取一个 C 字符串的长度， 程序必须遍历整个字符串复杂度为 O(N) ；</p>\n<p>SDS 在 <code>len</code> 属性中记录了 SDS 本身的长度， 所以获取一个 SDS 长度的复杂度仅为 O(1) 。</p>\n<h3 id=\"2-杜绝缓冲区溢出\"><a href=\"#2-杜绝缓冲区溢出\" class=\"headerlink\" title=\"2.杜绝缓冲区溢出\"></a>2.杜绝缓冲区溢出</h3><p> C 字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出（buffer overflow）</p>\n<p>与 C 字符串不同， SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性:当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间是否满足修改所需的要求， 如果不满足的话， API 会自动将 SDS 的空间扩展至执行修改所需的大小</p>\n<h4 id=\"缓冲区溢出\"><a href=\"#缓冲区溢出\" class=\"headerlink\" title=\"缓冲区溢出\"></a>缓冲区溢出</h4><p>假设程序里有两个在内存中紧邻着的 C 字符串 <code>s1</code> 和 <code>s2</code> ， 其中 <code>s1</code> 保存了字符串 <code>&quot;Redis&quot;</code> ， 而 <code>s2</code> 则保存了字符串 <code>&quot;MongoDB&quot;</code> ， 如图 2-7 所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/graphviz-7daf86931b270e1f4bacf20e3f56ebcb2fc7e08e.2ontyoior7a0.png\" alt=\"img\"></p>\n<p>如果一个程序员决定通过执行：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">strcat(s1, &quot; Cluster&quot;);</code></pre>\n\n<p><code>s1</code> 的内容修改为 <code>&quot;Redis Cluster&quot;</code> ， 但粗心的他却忘了在执行 <code>strcat</code> 之前为 <code>s1</code> 分配足够的空间， 那么在 <code>strcat</code> 函数执行之后， <code>s1</code> 的数据将溢出到 <code>s2</code> 所在的空间中， 导致 <code>s2</code> 保存的内容被意外地修改， 如图 2-8 所示:</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/graphviz-2ff855d462d63f935deedb05c0d6447ed4b44bb3.3oqo5ly1h040.png\" alt=\"img\"></p>\n<h3 id=\"3-减少修改字符串时带来的内存重分配次数\"><a href=\"#3-减少修改字符串时带来的内存重分配次数\" class=\"headerlink\" title=\"3.减少修改字符串时带来的内存重分配次数\"></a>3.减少修改字符串时带来的内存重分配次数</h3><p>每次增长或者缩短一个 C 字符串， 程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作：</p>\n<ul>\n<li>如果程序执行的是增长字符串的操作， 比如拼接操作（append）， 那么在执行这个操作之前， 程序需要先通过内存重分配来扩展底层数组的空间大小 —— 如果忘了这一步就会产生缓冲区溢出。</li>\n<li>如果程序执行的是缩短字符串的操作， 比如截断操作（trim）， 那么在执行这个操作之后， 程序需要通过内存重分配来释放字符串不再使用的那部分空间 —— 如果忘了这一步就会产生内存泄漏。</li>\n</ul>\n<p> 在 SDS 中， <code>buf</code> 数组的长度不一定就是字符数量加一， 数组里面可以包含未使用的字节， 而这些字节的数量就由 SDS 的 <code>free</code> 属性记录。通过未使用空间， SDS 实现了空间预分配和惰性空间释放两种优化策略。</p>\n<h4 id=\"空间预分配\"><a href=\"#空间预分配\" class=\"headerlink\" title=\"空间预分配\"></a>空间预分配</h4><p>当 SDS 的 API 对一个 SDS 进行修改， 并且需要对 SDS 进行空间扩展的时候， 程序不仅会为 SDS 分配修改所必须要的空间， 还会为 SDS 分配额外的未使用空间</p>\n<ul>\n<li>如果对 SDS 进行修改之后， SDS 的长度为13byte（也即是 <code>len</code> 属性的值）小于 <code>1 MB</code> ， 这时 SDS <code>len</code> 属性的值将和 <code>free</code> 属性的值相同都为13byte。</li>\n<li>如果对 SDS 进行修改之后， SDS 的长度为<code>2 MB</code>大于等于 <code>1 MB</code> ， SDS 的 <code>len</code> 将变成 <code>2 MB</code> ， <code>free</code>分配 <code>1 MB</code> 的未使用空间</li>\n</ul>\n<h4 id=\"惰性空间释放\"><a href=\"#惰性空间释放\" class=\"headerlink\" title=\"惰性空间释放\"></a>惰性空间释放</h4><p>当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 <code>free</code> 属性将这些字节的数量记录起来， 并等待将来使用。</p>\n<p>SDS 也提供了相应的 API ， 让我们可以在有需要时， 真正地释放 SDS 里面的未使用空间， 所以不用担心惰性空间释放策略会造成内存浪费。</p>\n<h3 id=\"4-二进制安全\"><a href=\"#4-二进制安全\" class=\"headerlink\" title=\"4.二进制安全\"></a>4.二进制安全</h3><p>C 字符串中的字符必须符合某种编码（比如 ASCII）， 并且除了字符串的末尾之外， 字符串里面不能包含空字符， 否则最先被程序读入的空字符将被误认为是字符串结尾 —— 这些限制使得 C 字符串只能保存文本数据， 而不能保存像图片、音频、视频、压缩文件这样的二进制数据。</p>\n<p>所有 SDS API 都会以处理二进制的方式来处理 SDS 存放在 <code>buf</code> 数组里的数据， 程序不会对其中的数据做任何限制、过滤、或者假设 —— 数据在写入时是什么样的， 它被读取时就是什么样。</p>\n<h3 id=\"5-兼容部分-C-字符串函数\"><a href=\"#5-兼容部分-C-字符串函数\" class=\"headerlink\" title=\"5.兼容部分 C 字符串函数\"></a>5.兼容部分 C 字符串函数</h3><p>虽然 SDS 的 API 都是二进制安全的， 但它们一样遵循 C 字符串以空字符结尾的惯例： 这些 API 总会将 SDS 保存的数据的末尾设置为空字符， 并且总会在为 <code>buf</code> 数组分配空间时多分配一个字节来容纳这个空字符， 这是为了让那些保存文本数据的 SDS 可以重用一部分 <code>&lt;string.h&gt;</code> 库定义的函数</p>\n<h2 id=\"SDS-API\"><a href=\"#SDS-API\" class=\"headerlink\" title=\"SDS API\"></a>SDS API</h2><table>\n<thead>\n<tr>\n<th align=\"left\">函数</th>\n<th align=\"left\">作用</th>\n<th align=\"left\">时间复杂度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>sdsnew</code></td>\n<td align=\"left\">创建一个包含给定 C 字符串的 SDS 。</td>\n<td align=\"left\">O(N) ， <code>N</code> 为给定 C 字符串的长度。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>sdsempty</code></td>\n<td align=\"left\">创建一个不包含任何内容的空 SDS 。</td>\n<td align=\"left\">O(1)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>sdsfree</code></td>\n<td align=\"left\">释放给定的 SDS 。</td>\n<td align=\"left\">O(1)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>sdslen</code></td>\n<td align=\"left\">返回 SDS 的已使用空间字节数。</td>\n<td align=\"left\">这个值可以通过读取 SDS 的 <code>len</code> 属性来直接获得， 复杂度为 O(1) 。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>sdsavail</code></td>\n<td align=\"left\">返回 SDS 的未使用空间字节数。</td>\n<td align=\"left\">这个值可以通过读取 SDS 的 <code>free</code> 属性来直接获得， 复杂度为 O(1) 。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>sdsdup</code></td>\n<td align=\"left\">创建一个给定 SDS 的副本（copy）。</td>\n<td align=\"left\">O(N) ， <code>N</code> 为给定 SDS 的长度。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>sdsclear</code></td>\n<td align=\"left\">清空 SDS 保存的字符串内容。</td>\n<td align=\"left\">因为惰性空间释放策略，复杂度为 O(1) 。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>sdscat</code></td>\n<td align=\"left\">将给定 C 字符串拼接到 SDS 字符串的末尾。</td>\n<td align=\"left\">O(N) ， <code>N</code> 为被拼接 C 字符串的长度。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>sdscatsds</code></td>\n<td align=\"left\">将给定 SDS 字符串拼接到另一个 SDS 字符串的末尾。</td>\n<td align=\"left\">O(N) ， <code>N</code> 为被拼接 SDS 字符串的长度。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>sdscpy</code></td>\n<td align=\"left\">将给定的 C 字符串复制到 SDS 里面， 覆盖 SDS 原有的字符串。</td>\n<td align=\"left\">O(N) ， <code>N</code> 为被复制 C 字符串的长度。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>sdsgrowzero</code></td>\n<td align=\"left\">用空字符将 SDS 扩展至给定长度。</td>\n<td align=\"left\">O(N) ， <code>N</code> 为扩展新增的字节数。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>sdsrange</code></td>\n<td align=\"left\">保留 SDS 给定区间内的数据， 不在区间内的数据会被覆盖或清除。</td>\n<td align=\"left\">O(N) ， <code>N</code> 为被保留数据的字节数。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>sdstrim</code></td>\n<td align=\"left\">接受一个 SDS 和一个 C 字符串作为参数， 从 SDS 左右两端分别移除所有在 C 字符串中出现过的字符。</td>\n<td align=\"left\">O(M*N) ， <code>M</code> 为 SDS 的长度， <code>N</code> 为给定 C 字符串的长度。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>sdscmp</code></td>\n<td align=\"left\">对比两个 SDS 字符串是否相同。</td>\n<td align=\"left\">O(N) ， <code>N</code> 为两个 SDS 中较短的那个 SDS 的长度。</td>\n</tr>\n</tbody></table>\n","feature":true,"text":"SDS 简单动态字符串（simple dynamic string）Redis 没有直接使用C语言传统的字符串表示，而是自己构建了一种名为简单动态字符串（simple dynamic string SDS）的抽象类型，并将SDS用作Redis 的默认字符串表示。 SDS定义str...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":14,"path":"api/categories/学习记录.json"}],"tags":[{"name":"Redis","slug":"Redis","count":1,"path":"api/tags/Redis.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#SDS-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88simple-dynamic-string%EF%BC%89\"><span class=\"toc-text\">SDS 简单动态字符串（simple dynamic string）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SDS%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">SDS定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SDS%E4%B8%8EC%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">SDS与C字符串区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%B8%B8%E6%95%B0%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6\"><span class=\"toc-text\">1.常数复杂度获取字符串长度</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%9D%9C%E7%BB%9D%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA\"><span class=\"toc-text\">2.杜绝缓冲区溢出</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA\"><span class=\"toc-text\">缓冲区溢出</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%87%8F%E5%B0%91%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%97%B6%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%86%85%E5%AD%98%E9%87%8D%E5%88%86%E9%85%8D%E6%AC%A1%E6%95%B0\"><span class=\"toc-text\">3.减少修改字符串时带来的内存重分配次数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A9%BA%E9%97%B4%E9%A2%84%E5%88%86%E9%85%8D\"><span class=\"toc-text\">空间预分配</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%83%B0%E6%80%A7%E7%A9%BA%E9%97%B4%E9%87%8A%E6%94%BE\"><span class=\"toc-text\">惰性空间释放</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">4.二进制安全</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%85%BC%E5%AE%B9%E9%83%A8%E5%88%86-C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">5.兼容部分 C 字符串函数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SDS-API\"><span class=\"toc-text\">SDS API</span></a></li></ol></li></ol>","author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":""}},"mapped":true,"prev_post":{"title":"ZooKeeper：分布式协调服务","uid":"ea4f29ef076f8fcb5cf3c8e4ef9a996f","slug":"zookeeper/zk","date":"2020-10-05T10:32:47.000Z","updated":"2022-01-02T16:47:54.095Z","comments":true,"path":"api/articles/zookeeper/zk.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image.6sh7yd2sglk0.png","text":"ZooKeeper：分布式协调服务统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。 ZooKeeper提供的名称空间与标准文件系统的名称空间非常相似 其中每个节点称为znode 持久节点 临时节点 会话关闭消失 顺序节点 zk都会在路径后面自动添加上10位的数字 ...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":14,"path":"api/categories/学习记录.json"}],"tags":[{"name":"Zookeeper","slug":"Zookeeper","count":1,"path":"api/tags/Zookeeper.json"}],"author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":""}}},"next_post":{"title":"线程池总结","uid":"6199f8896169806e8b51dc181ed51cca","slug":"java/threadpool","date":"2020-06-29T10:32:47.000Z","updated":"2022-01-03T13:23:44.755Z","comments":true,"path":"api/articles/java/threadpool.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/149081619256095_.pic_hd.3gam3xte6me0.jpg","text":"七大参数 corePoolSize 线程池核心线程大小 maximumPoolSize 线程池最大线程数量 keepAliveTime 空闲线程存活时间 unit 空间线程存活时间单位 workQueue 工作队列 threadFactory 线程工厂 创建一个新线程时使用的工厂...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":14,"path":"api/categories/学习记录.json"}],"tags":[{"name":"Java","slug":"Java","count":3,"path":"api/tags/Java.json"}],"author":{"name":"Polnareff","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/jp-polnareff/image-hosting@master/20210423/image123.47oj8cvm3fu0.jpg","link":"/","description":"Travel around in search of her sister's killer","socials":{"github":"https://github.com/jp-polnareff","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":""}}}}